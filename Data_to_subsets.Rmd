**Script Author:** Luca van Leeuwen 
**Data source:** A single-cell atlas of the multicellular ecosystem of primary and metastatic hepatocellular carcinoma. _(Lu et al., 2022)_. 
**GEO Accession number:** GSE149614 _(Downloaded 10/04/25)_

---  
## Import required packages.

```{r import required packages, include=FALSE}
library(data.table)
library(Seurat)
library(ggplot2)
library(RColorBrewer)
library(harmony)
library(dplyr)
library(patchwork)
library(ggpubr)
library(EnhancedVolcano)
library(fgsea)
library(SeuratWrappers)
library(monocle3)
library(VennDiagram)
library(pheatmap)
library(dendextend)
library(pcaPP)
library(tibble)
library(ggpointdensity)
library(viridis)

options(future.globals.maxSize = 16 *  1024^3)
```
---  
# Data to Subsets.
## 1. Create a Seurat object.

```{r create a Seurat object, echo=FALSE}
# Read in the count matrix as a data frame.
counts.matrix <- as.data.frame(fread("Data/GSE149614_HCC.scRNAseq.S71915.count.txt"))

# Set the gene names as row names.
rownames(counts.matrix) <- counts.matrix[,1] 

# Remove the gene names column.
counts.matrix <- counts.matrix[,-1]

# Remove portal vein and lymph node samples.
counts.matrix <- counts.matrix[,!grepl("P|L",colnames(counts.matrix))] 

# Convert into a Seurat object.
Seurat.object <- CreateSeuratObject(
        counts = counts.matrix, 
        project = "GSE149614")

# Add condition to the metadata.
Seurat.object$Condition <- ifelse(
        grepl("T", Seurat.object$orig.ident),
        "Tumor", "Tumor free") 

# Take a look at the meta data.
print(Seurat.object@meta.data) 

# Keep the Data/Value section clean.
rm(counts.matrix)
```

---  
## 2. Quality Control (already performed).

```{r quality control, echo=FALSE}
# Add the percentage of mitochondrial genes to the meta data.
Seurat.object <- PercentageFeatureSet(
        Seurat.object,
        pattern = "^MT-",
        col.name = "percent.mt"
)

# Plot and save the cleaned reads.
VlnPlot(object = Seurat.object,
        features = "nCount_RNA",
        pt.size = 0,
        cols = replicate(length(unique(Seurat.object$orig.ident)), "#1b9e77")) +
        theme(legend.position = 'none', axis.title.x = element_blank()) +
        ggtitle("Cleaned Reads (count)") + 
        geom_hline(yintercept = 2000) + 
        scale_y_continuous(limits = c(0,130000), n.breaks = 13)

# Plot and save the cleaned genes.
VlnPlot(object = Seurat.object, 
        features = "nFeature_RNA", 
        pt.size = 0, 
        cols = replicate(length(unique(Seurat.object$orig.ident)), "#d95f02")) + 
        theme (legend.position = 'none', axis.title.x = element_blank()) + 
        ggtitle("Cleaned Genes (count)") + 
        geom_hline(yintercept = c(6000)) + 
        scale_y_continuous(limits = c(0, 9000), n.breaks = 9) 

# Plot and save the cleaned Mitochondrial fraction.
VlnPlot(object = Seurat.object, 
        features = "percent.mt", 
        pt.size = 0, 
        cols = replicate(length(unique(Seurat.object$orig.ident)), "#7570b3"), 
        y.max = 20) +
        theme(legend.position = 'none', axis.title.x = element_blank()) + 
        ggtitle("Cleaned Mitochondrial (%)")

# Plot and save the number of high-quality cells per sample.
ggplot(data = Seurat.object@meta.data,
       aes(x = orig.ident)) +
        geom_bar(fill ="#1f78b4", color = "black") + 
        ggtitle("Number of High-Quality Cells") + 
        xlab("Sample") + 
        theme(panel.background = element_blank(), 
              axis.line = element_line(colour = "black"), 
              legend.position = 'none', 
              axis.title.y = element_blank(), 
              plot.title = element_text(hjust = 0.5), 
              axis.text.x = element_text(angle = 90))
```

---  
## 3. Normalization and Feature Selection.

```{r normalization and feature selection, include=FALSE}
# Normalize the samples.
Seurat.object <- SCTransform(object = Seurat.object, 
                             assay = 'RNA', 
                             new.assay.name = 'SCT', 
                             vst.flavor = "v2",
                             verbose = F,
                             ncells=5000,
                             conserve.memory=TRUE)
```
---
## 4. Linear dimensionality reduction (PCA).

```{r PCA, echo=FALSE}
# Run PCA.
Seurat.object <- RunPCA(object = Seurat.object, 
                        verbose = F)

# Determine dimensionality of the data.
ElbowPlot(object = Seurat.object,
          ndims = 50,
          reduction = "pca") 
```
---
## 5. Non-linear dimension reduction for visualization (UMAP).

```{r UMAP, echo=FALSE}
# Run UMAP.
Seurat.object <- RunUMAP(object = Seurat.object, 
                         dims = 1:30)

# Plot and save the UMAP.
UMAPPlot(object = Seurat.object,
         cols = colorRampPalette(brewer.pal(12, "Paired"))(20)) +
        ggtitle("Prior integration UMAP plot")
```
---
## 6. Integration.

```{r integration, echo=FALSE}
# Integrate samples.
Seurat.object <- RunHarmony(object = Seurat.object,
                            group.by.vars = "orig.ident",
                            reduction.use = "pca",
                            reduction.save = "harmony",
                            assay.use = "SCT")

# Run UMAP.
Seurat.object <- RunUMAP(object = Seurat.object, 
                         dims = 1:30, 
                         reduction = "harmony")

# Plot and save the integrated UMAP.
UMAPPlot(object = Seurat.object,
         cols = colorRampPalette(brewer.pal(12, "Paired"))(20)) + 
        ggtitle("Post integration UMAP plot")
```
---
## 7. Clustering.

```{r clustering, echo=FALSE}
# Find neighbors.
Seurat.object <- FindNeighbors(object = Seurat.object, 
                               reduction = "harmony", 
                               dims = 1:30)

# Plot and save resolution clusters.
Seurat.object <- FindClusters(object = Seurat.object, 
                              resolution = 0.2)

UMAPPlot(object = Seurat.object,
         label = T,
         cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(Seurat.object))))) +
        ggtitle(paste0("Resolution of 0.2"))
```
---
## 8. Check marker gene expression.

```{r check marker gene expression, echo=FALSE}
# To access the normalized expression levels of all genes, we can use the normalized RNA data.
DefaultAssay(Seurat.object) <- "RNA" 
Seurat.object <- NormalizeData(Seurat.object, 
                               verbose = F)

# Create a list with marker genes per cell type.
Feature.list <- list()
Feature.list[["T_NK"]] <- c("CD3E", "NKG7")
Feature.list[["B"]] <- c("JCHAIN", "CD79A")
Feature.list[["Myeloid"]] <- c("LYZ", "CD68", "CD14")
Feature.list[["Endo"]] <- c("PECAM1", "FCGR2B")
Feature.list[["Fib"]] <- c("ACTA2", "COL1A1")
Feature.list[["Hep"]] <- c("ALB", "SERPINA1")

# Plot and save marker gene expression.
for (i in names(Feature.list)) {
        print(
                FeaturePlot(Seurat.object,
                            features = Feature.list[[i]],
                            min.cutoff = 'q10',
                            label = T,
                            cols = c("grey90", "#bd0026"))
        )
}

# Keep the Data/Value section clean.
rm(Feature.list, i) 
```
---

```{r check marker gene expression (2), include=FALSE}
# Retrieve the top genes that differentiate the clusters from each other. 
Subset.Markers <- FindAllMarkers(Seurat.object,
                                 only.pos = T,
                                 logfc.threshold = 0.25,
                                 min.diff.pct = 0.25,
                                 min.pct = 0.25)
```
---
## 9. Annotate cell clusters.

```{r annotate cell clusters, echo=FALSE}
# Rename clusters to their hypothesized cell identities.
Seurat.object <- RenameIdents(object = Seurat.object,
                              '0' = 'T/NK',
                              '1' = 'Hepatocyte',
                              '2' = 'Myeloid',
                              '3' = 'Myeloid',
                              '4' = 'T/NK',
                              '5' = 'T/NK',
                              '6' = 'Endothelial',
                              '7' = 'Hepatocyte',
                              '8' = 'Fibroblast',
                              '9' = 'Endothelial',
                              '10' = 'B',
                              '11' = 'B',
                              '12' = 'T/NK',
                              '13' = 'Hepatocyte',
                              '14' = 'B',
                              '15' = 'Hepatocyte',
                              '16' = 'Hepatocyte',
                              '17' = 'B') 

# Visualize the annotated clusters.
DimPlot(Seurat.object,
        cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(Seurat.object))))) + 
        ggtitle("UMAP plot of annotated cell clusters")
```
---
## 10. Quality check.

```{r Quality check, echo=FALSE}
# Read in the meta data.
meta <- as.data.frame(fread("Data//GSE149614_HCC.metadata.updated.txt", 
                            header = TRUE, 
                            sep = "\t")) 

# Filter based on leftover cell barcodes.
meta.filtered <- meta[meta$Cell %in% colnames(Seurat.object), ]

# Set the barcodes as rownames.
rownames(meta.filtered) = meta.filtered[["Cell"]] 

# Add a column with the cell. information from the paper
Seurat.object$Feature_Column <- meta.filtered[colnames(Seurat.object), 
                                              "celltype"] 

# Plot and save.
DimPlot(Seurat.object, 
        group.by = "Feature_Column", 
        cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(Seurat.object))))) + 
        ggtitle("UMAP plot of annotated cell clusters by paper") 

# Keep the Data/Value section clean.
rm(meta, meta.filtered) 
```
---

```{r save the final Seurat object, include=FALSE}
# save a backup of the final Seurat object.
saveRDS(Seurat.object, 
        file = gzfile("Output/FBSeuratObject.rds.gz")) 
```
---
# CD4/CD8 T-cells/focus on tumor
## 1. Subset the T clusters.
* Seurat.object <- readRDS(file = "Output/FBSeuratObject.rds.gz")
```{r Subset desired T-cell clusters, include=FALSE}
# Subset the T/NK cells.
T.object <- subset(Seurat.object, 
                         idents = "T/NK")

# Set identity to tissue type.
Idents(T.object) <- T.object$Condition

# Subset the tumor cells.
T.object <- subset(T.object, 
                         idents = "Tumor")
```
---
## 2. Re-scale the T/NK clusters.

```{r re-scale the T-cell clusters, include=FALSE}
# Add cell cycle scores to meta data.
T.object <- CellCycleScoring(object = T.object, 
                             s.features = cc.genes$s.genes, 
                             g2m.features = cc.genes$g2m.genes)

# Split the object into layers to run SCtransform for the samples separately.  
T.object[["RNA"]] <- split(T.object[["RNA"]],
                           T.object$orig.ident) 

# Re-run normalization to re-scale based only on Myeloid cells.
T.object <- SCTransform(object = T.object, 
                        assay = 'RNA',
                        new.assay.name = 'SCT',
                        vst.flavor = "v2",
                        verbose = F,
                        ncells=5000,
                        vars.to.regress = c("percent.mt", 
                                            "S.Score", 
                                            "G2M.Score"))

# Run PCA.
T.object <- RunPCA(T.object) 

# Determine the dimensionality of the data.
ElbowPlot(T.object,
          ndims = 50) 

# Keep the Data/Value section clean.
rm(Seurat.object)
```
---
## 3. Non-linear dimension reduction for visualization (UMAP).

```{r UMAP, echo=FALSE}
# Run UMAP.
T.object <- RunUMAP(T.object, 
                    dims = 1:30)

# Print and save the un-integrated plot.
UMAPPlot(T.object,
         group.by = "orig.ident",
         cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(T.object$orig.ident)))) + 
        ggtitle("T/NK plot")
```
---
## 5. Clustering the T/NK subset.

```{r clustering the myeloid subset, echo=FALSE}
# To access the normalized expression levels of all genes, we can use the normalized RNA data.
DefaultAssay(T.object) <- "RNA" 
T.object <- NormalizeData(T.object,
                                verbose = F)
T.object <- JoinLayers(T.object)

# Create a list with marker genes per cell type.
Feature.list <- list()
Feature.list[["T-cell"]] <- c("CD3E", "CD3D")
Feature.list[["NK cell"]] <- c("NKG7", "KLRD1", "NCAM1", "NCR1")
Feature.list[["CD4 T-cell"]] <- c("CD4", "CCR7", "LEF1", "SELL")
Feature.list[["Treg cell"]] <- c( "CD4", "FOXP3", "CTLA4", "TIGIT", "LAYN")
Feature.list[["CD8 T-cell"]] <- c("CD8A", "CD8B", "GZMA", "GZMB", "GZMH", "PRF1", "EOMES")

# Calculate the average expression of the set of specified gene signatures for each cell.
for (i in names(Feature.list)) {
        y <- list(Feature.list[[i]])
        T.object <- AddModuleScore(T.object, 
                                         features = y, 
                                         name = names(Feature.list)[i]) 
        
        # Plot and save gene signature expression.
        print(
                FeaturePlot(T.object,
                            features = paste0(names(Feature.list)[i],"1"),
                            label = F,
                            min.cutoff = 'q10',
                            order = T,
                            pt.size = 1.5) + 
                        ggtitle(paste0(i)) +
                        scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))
        )
} 

# Set assay back to SCT
DefaultAssay(T.object) <- "SCT" 

# Find neighbors.
T.object <- FindNeighbors(T.object,
                          dims = 1:30) 

# Plot and save resolution clusters.
for (i in c(0.1, 0.2, 0.3, 0.4, 0.5)) {
        T.object <- FindClusters(object = T.object,
                                 resolution = i)
        
        print(UMAPPlot(object = T.object,
                       label = T,
                       cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(T.object))))) +
                      ggtitle(paste0("Resolution of ", i)) +
                      theme(plot.title = element_text(hjust = 0.5))) }

# Set the desired resolution.
Idents(T.object) = T.object$SCT_snn_res.0.3

# Keep the Data/Value section clean.
rm(Feature.list, i, y) 
```
---
## 6. Check marker gene expression.
* Some aspecific, but also predent in paper metadata
```{r check marker gene expression, include=FALSE}
DefaultAssay(T.object) <- "RNA" 

# Retrieve the top genes that differentiate the clusters from each other. 
T.Markers <- FindAllMarkers(T.object, 
                            only.pos = T, 
                            logfc.threshold = 0.25,
                            min.diff.pct = 0.25,
                            min.pct = 0.25)
```

---
## 7. Annotate cell clusters.

```{r annotate the myeloid clusters, echo=FALSE}
# Rename clusters to their hypothesized cell identities.
T.object <- RenameIdents(object = T.object,
                         '0' = 'CD4 T-cells',
                         '1' = 'CD8 T-cells',
                         '2' = 'Treg cells',
                         '3' = 'NK cells',
                         '4' = 'Epithelial',
                         '5' = 'CD4 T-cells',
                         '6' = 'B-cells',
                         '7' = 'Mast cells'
) 

# Also save the annotations in the metadata
T.object$annotation <- Idents(T.object) 

# Option to remove suspected NK/T-cells and Hepatocytes.
CD4.object <- subset(T.object, idents = c("CD4 T-cells", "Treg cells")) 

# Option to remove suspected NK/T-cells and Hepatocytes.
CD8.object <- subset(T.object, idents = c("CD8 T-cells")) 


# Split the object into layers to run SCtransform for the samples separately.  
CD4.object[["RNA"]] <- split(CD4.object[["RNA"]],
                             CD4.object$orig.ident) 
# Split the object into layers to run SCtransform for the samples separately.  
CD8.object[["RNA"]] <- split(CD8.object[["RNA"]],
                             CD8.object$orig.ident) 

# Re-run normalization to re-scale based only on T cells.
CD4.object <- SCTransform(object = CD4.object, 
                          assay = 'RNA',
                          new.assay.name = 'SCT',
                          vst.flavor = "v2",
                          verbose = F,
                          ncells=5000)
# Re-run normalization to re-scale based only on T cells.
CD8.object <- SCTransform(object = CD8.object, 
                          assay = 'RNA',
                          new.assay.name = 'SCT',
                          vst.flavor = "v2",
                          verbose = F,
                          ncells=5000)

# Run PCA.
CD4.object <- RunPCA(CD4.object) 
CD8.object <- RunPCA(CD8.object) 

# Run UMAP.
CD4.object <- RunUMAP(CD4.object, 
             dims = 1:30)
CD8.object <- RunUMAP(CD8.object, 
             dims = 1:30)


# Visualize the annotated clusters.
UMAPPlot(
        object = CD4.object,
        cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(CD4.object))))) +
        theme(plot.title = element_text(hjust = 0.5))

# Visualize the annotated clusters.

UMAPPlot(
        object = CD8.object,
        cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(CD8.object))))) +
        theme(plot.title = element_text(hjust = 0.5))
```
---

```{r Vislualize markers of interest, echo=FALSE}
# To access the normalized expression levels of all genes, we can use the normalized RNA data.
DefaultAssay(CD4.object) <- "RNA" 
CD4.object <- NormalizeData(CD4.object,
                                verbose = F)
# To access the normalized expression levels of all genes, we can use the normalized RNA data.
DefaultAssay(CD8.object) <- "RNA" 
CD8.object <- NormalizeData(CD8.object,
                                verbose = F)

CD4.object <- JoinLayers(CD4.object)
CD8.object <- JoinLayers(CD8.object)

# Plot features of interest.
FeaturePlot(CD4.object, features = c("ENTPD1", "PDCD1"),
            order = T,
            pt.size = 1.5) &
        scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))

FeaturePlot(CD8.object, features = c("ENTPD1", "PDCD1"),
            order = T,
            pt.size = 2) &
        scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))

# To access the normalized expression levels of all genes, we can use the normalized RNA data.
DefaultAssay(CD4.object) <- "SCT" 
DefaultAssay(CD8.object) <- "SCT" 

# Find neighbors.
CD4.object <- FindNeighbors(CD4.object,
                   dims = 1:30)
CD8.object <- FindNeighbors(CD8.object,
                   dims = 1:30)

# Plot and save resolution clusters.
for (i in c(0.1, 0.2, 0.3, 0.4, 0.5)) {
        CD4.object <- FindClusters(object = CD4.object,
                          resolution = i)
        
        print(UMAPPlot(object = CD4.object,
                       label = T,
                       cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(CD4.object))))) +
                      ggtitle(paste0("Resolution of ", i)) +
                      theme(plot.title = element_text(hjust = 0.5))) }

for (i in c(0.1, 0.2, 0.3, 0.4, 0.5)) {
        CD8.object <- FindClusters(object = CD8.object,
                          resolution = i)
        
        print(UMAPPlot(object = CD8.object,
                       label = T,
                       cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(CD8.object))))) +
                      ggtitle(paste0("Resolution of ", i)) +
                      theme(plot.title = element_text(hjust = 0.5))) }


# Set the desired resolution.
Idents(CD4.object) = CD4.object$SCT_snn_res.0.5
Idents(CD8.object) = CD8.object$SCT_snn_res.0.5
```
---

```{r Trial, echo=FALSE}
DefaultAssay(CD8.object) <- "RNA" 

# Use the scaled data as input for the heatmap.
CD8.object <- ScaleData(CD8.object, 
                        verbose = FALSE)

# Calculate the average expression of the genes per cluster.
Heatmap.object <- AverageExpression(CD8.object, 
                                    assays = "RNA", 
                                    return.seurat = T, 
                                    layer = "scale.data")  

# Plot and save a heatmap of the top 5 marker genes per cluster.
DoHeatmap(Heatmap.object, 
          features = c("PDCD1", "ENTPD1"), 
          label = T, 
          size = 4, 
          angle = 0, 
          hjust = 0.5, 
          vjust = 0.5, 
          draw.lines = F) + 
        scale_fill_gradientn(colors = rev(RColorBrewer::brewer.pal(n=11, name = "Spectral"))) + 
        guides(color = "none") + 
        theme(axis.text.y = element_text(size = 6))

  
  # Plot CD169 expression within the UMAP of myeloid clusters.
  FeaturePlot(CD8.object, 
              features=c("ENTPD1"),
              label = T,
              order = T) + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, 
                                                  name = "Spectral"))) + 
  theme(plot.title = element_blank(), 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank()) + 
  coord_fixed(ratio = 1.5) | 
  
   # Plot CD169 expression by violin plot per myeloid cluster.
  VlnPlot(CD8.object, 
          features = c("ENTPD1"), 
          pt.size = 1, 
          cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(CD8.object))))) + 
  theme(legend.position = "none", 
        plot.title = element_blank(), 
        axis.text.x = element_text(size = 7.5), 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank()) + 
  coord_fixed(ratio = 3)
  
  # Plot CD169 expression within the UMAP of myeloid clusters.
  FeaturePlot(CD8.object, 
              features=c("PDCD1"),
              label = T,
              order = T) + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, 
                                                  name = "Spectral"))) + 
  theme(plot.title = element_blank(), 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank()) + 
  coord_fixed(ratio = 1.5) | 
  
   # Plot CD169 expression by violin plot per myeloid cluster.
  VlnPlot(CD8.object, 
          features = c("PDCD1"), 
          pt.size = 1, 
          cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(CD8.object))))) + 
  theme(legend.position = "none", 
        plot.title = element_blank(), 
        axis.text.x = element_text(size = 7.5), 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank()) + 
  coord_fixed(ratio = 3)

# Rename clusters to their hypothesized cell identities.
CD8.object <- RenameIdents(object = CD8.object,
                         '0' = 'PD1-CD39-',
                         '1' = 'PD1-CD39-',
                         '2' = 'PD1+CD39-',
                         '3' = 'PD1+CD39+',
                         '4' = 'PD1-CD39+'
) 

```
---

```{r Trial, echo=FALSE}
# Retrieve the top genes that differentiate the clusters from each other. 
CD8.Markers <- FindAllMarkers(CD8.object,
                              only.pos = T) 

# Extract the top 5 genes for each cluster.
Heatmap.Markers <- pull(slice_head(arrange(group_by(filter(CD8.Markers, 
                                                           p_val_adj < 0.05), 
                                                    cluster), 
                                           desc(avg_log2FC)), 
                                   n = 5), 
                        gene)

# Plot and save a heatmap of the top 5 marker genes per cluster.
DoHeatmap(Heatmap.object, 
               features = Heatmap.Markers, 
               label = T, 
               size = 4, 
               angle = 0, 
               hjust = 0.5, 
               vjust = 0.5, 
               draw.lines = F, 
               group.colors = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(CD8.object))))) + 
  scale_fill_gradientn(colours = rev(brewer.pal(n = 11,name = "Spectral"))) + 
  guides(color = "none") + 
  theme(axis.text.y = element_text(size = 6))

# Retrieve marker genes that differentiate Macro2 from other myeloid clusters combined.
Macro2.Markers <- FindMarkers(CD8.object, 
                              ident.1 = "PD1+CD39+")

# Plot the differentially expressed genes as a volcano.
EnhancedVolcano(Macro2.Markers, 
                row.names(Macro2.Markers), 
                x="avg_log2FC", 
                y="p_val_adj") + 
        ggtitle("Differentially expressed genes of the Macro2 cluster") 

# Arrange the DEGs according to avg_log2FC and only keep significant genes. 
Macro2.Markers <- arrange(filter(Macro2.Markers, 
                                 p_val_adj < 0.05), 
                          desc(avg_log2FC))

# Extract the avg_log2FC value.
Macro2.FC <- Macro2.Markers$avg_log2FC 

# Add gene names.
names(Macro2.FC) <- rownames(Macro2.Markers) 

# Set directory to the location of the GSEA data sets.
setwd("/Users/lucavanleeuwen/Documents/R script/Data")

# Prepare an empty list.
GSEA.list <- list() 

# Add the GO dataset.
GSEA.list[["GO"]] <- fgsea::gmtPathways("c5.go.bp.v2024.1.Hs.symbols.gmt.txt") 
# Add the Curated Cancer Cell Atlas dataset.
GSEA.list[["CCCA"]] <- fgsea::gmtPathways("c4.3ca.v2024.1.Hs.symbols.gmt.txt") 
# Add the Reactome dataset.
GSEA.list[["Reactome"]] <- fgsea::gmtPathways("c2.cp.reactome.v2024.1.Hs.symbols.gmt.txt") # Add the Hallmark dataset.
GSEA.list[["Hallmark"]] <- fgsea::gmtPathways("h.all.v2024.1.Hs.symbols.gmt.txt") 
# Add the cell type signature dataset.
GSEA.list[["Cell type"]] <- fgsea::gmtPathways("c8.all.v2024.1.Hs.symbols.gmt.txt") 

# Put back directory.
setwd("/Users/lucavanleeuwen/Documents/R script/Data")

# Perform GSEA analysis
for (i in names(GSEA.list)) {
  Macro2.GSEA <- fgsea(pathways = GSEA.list[[i]], 
                       stats = Macro2.FC, 
                       eps = 0.0, 
                       minSize=15, 
                       maxSize=500) 
  
  # Extract significant pathways.
  Macro2.GSEA <- Macro2.GSEA[Macro2.GSEA$padj < 0.05, ]
  
  # Retrieve the top 5 pathways associated with Macro2 DEGs.
  Up.pathways <- head(Macro2.GSEA[ES > 0][order(pval),][,pathway], 
                      n = 5)
  Down.pathways <- head(Macro2.GSEA[ES < 0][order(pval),][,pathway], 
                        n = 5)
  Macro2.pathways <- c(Up.pathways, 
                       rev(Down.pathways)) 

  # Plot the GSEA.
  print(plotGseaTable(GSEA.list[[i]][Macro2.pathways], 
                     Macro2.FC, 
                     Macro2.GSEA, 
                     gseaParam = 0.5, 
                     pathwayLabelStyle=list(size = 6, 
                                            color = "#2171b5"), 
                     headerLabelStyle = list(size = 8, 
                                             color = "#084594"), 
                     valueStyle = list(size = 10), 
                     axisLabelStyle = list(size = 7)))
}
 
```
---

```{r Trial, echo=FALSE}
DefaultAssay(CD4.object) <- "RNA" 

# Use the scaled data as input for the heatmap.
CD4.object <- ScaleData(CD4.object, 
                        verbose = FALSE)

# Calculate the average expression of the genes per cluster.
Heatmap.object <- AverageExpression(CD4.object, 
                                    assays = "RNA", 
                                    return.seurat = T, 
                                    layer = "scale.data")  

# Plot and save a heatmap of the top 5 marker genes per cluster.
DoHeatmap(Heatmap.object, 
          features = c("PDCD1", "ENTPD1"), 
          label = T, 
          size = 4, 
          angle = 0, 
          hjust = 0.5, 
          vjust = 0.5, 
          draw.lines = F) + 
        scale_fill_gradientn(colors = rev(RColorBrewer::brewer.pal(n=11, name = "Spectral"))) + 
        guides(color = "none") + 
        theme(axis.text.y = element_text(size = 6))

  
  # Plot CD169 expression within the UMAP of myeloid clusters.
  FeaturePlot(CD4.object, 
              features=c("ENTPD1"),
              label = T,
              order = T) + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, 
                                                  name = "Spectral"))) + 
  theme(plot.title = element_blank(), 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank()) + 
  coord_fixed(ratio = 1.5) | 
  
   # Plot CD169 expression by violin plot per myeloid cluster.
  VlnPlot(CD4.object, 
          features = c("ENTPD1"), 
          pt.size = 0, 
          cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(CD4.object))))) + 
  theme(legend.position = "none", 
        plot.title = element_blank(), 
        axis.text.x = element_text(size = 7.5), 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank()) + 
  coord_fixed(ratio = 3)
  
  # Plot CD169 expression within the UMAP of myeloid clusters.
  FeaturePlot(CD4.object, 
              features=c("PDCD1"),
              label = T,
              order = T) + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, 
                                                  name = "Spectral"))) + 
  theme(plot.title = element_blank(), 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank()) + 
  coord_fixed(ratio = 1.5) | 
  
   # Plot CD169 expression by violin plot per myeloid cluster.
  VlnPlot(CD4.object, 
          features = c("PDCD1"), 
          pt.size = 0, 
          cols = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(CD4.object))))) + 
  theme(legend.position = "none", 
        plot.title = element_blank(), 
        axis.text.x = element_text(size = 7.5), 
        axis.title.x = element_blank(), 
        axis.title.y = element_blank()) + 
  coord_fixed(ratio = 3)

# Retrieve the top genes that differentiate the clusters from each other. 
CD8.Markers <- FindAllMarkers(CD4.object) 

```
---

```{r Trial, echo=FALSE}
# Extract the top 5 genes for each cluster.
Heatmap.Markers <- pull(slice_head(arrange(group_by(filter(CD8.Markers, 
                                                           p_val_adj < 0.05), 
                                                    cluster), 
                                           desc(avg_log2FC)), 
                                   n = 5), 
                        gene)

# Plot and save a heatmap of the top 5 marker genes per cluster.
DoHeatmap(Heatmap.object, 
               features = Heatmap.Markers, 
               label = T, 
               size = 4, 
               angle = 0, 
               hjust = 0.5, 
               vjust = 0.5, 
               draw.lines = F, 
               group.colors = colorRampPalette(brewer.pal(12, "Paired"))(length(unique(Idents(CD4.object))))) + 
  scale_fill_gradientn(colors = rev(RColorBrewer::brewer.pal(n=4, name = "RdBu"))) + 
  guides(color = "none") + 
  theme(axis.text.y = element_text(size = 6))

# Retrieve marker genes that differentiate Macro2 from other myeloid clusters combined.
Macro2.Markers <- FindMarkers(CD4.object, 
                              ident.1 = "2", 
                              logfc.threshold = 0.25)


# Plot the differentially expressed genes as a volcano.
EnhancedVolcano(Macro2.Markers, 
                row.names(Macro2.Markers), 
                x="avg_log2FC", 
                y="p_val_adj") + 
        ggtitle("Differentially expressed genes of the Macro2 cluster") 

# Arrange the DEGs according to avg_log2FC and only keep significant genes. 
Macro2.Markers <- arrange(filter(Macro2.Markers, 
                                 p_val_adj < 0.05), 
                          desc(avg_log2FC))

# Extract the avg_log2FC value.
Macro2.FC <- Macro2.Markers$avg_log2FC 

# Add gene names.
names(Macro2.FC) <- rownames(Macro2.Markers) 

# Set directory to the location of the GSEA data sets.
setwd("/Users/lucavanleeuwen/Documents/R script/Data")

# Prepare an empty list.
GSEA.list <- list() 

# Add the GO dataset.
GSEA.list[["GO"]] <- fgsea::gmtPathways("c5.go.bp.v2024.1.Hs.symbols.gmt.txt") 
# Add the Curated Cancer Cell Atlas dataset.
GSEA.list[["CCCA"]] <- fgsea::gmtPathways("c4.3ca.v2024.1.Hs.symbols.gmt.txt") 
# Add the Reactome dataset.
GSEA.list[["Reactome"]] <- fgsea::gmtPathways("c2.cp.reactome.v2024.1.Hs.symbols.gmt.txt") # Add the Hallmark dataset.
GSEA.list[["Hallmark"]] <- fgsea::gmtPathways("h.all.v2024.1.Hs.symbols.gmt.txt") 
# Add the cell type signature dataset.
GSEA.list[["Cell type"]] <- fgsea::gmtPathways("c8.all.v2024.1.Hs.symbols.gmt.txt") 

# Put back directory.
setwd("/Users/lucavanleeuwen/Documents/R script/Data")

# Perform GSEA analysis
for (i in names(GSEA.list)) {
  Macro2.GSEA <- fgsea(pathways = GSEA.list[[i]], 
                       stats = Macro2.FC, 
                       eps = 0.0, 
                       minSize=15, 
                       maxSize=500) 
  
  # Extract significant pathways.
  Macro2.GSEA <- Macro2.GSEA[Macro2.GSEA$padj < 0.05, ]
  
  # Retrieve the top 5 pathways associated with Macro2 DEGs.
  Up.pathways <- head(Macro2.GSEA[ES > 0][order(pval),][,pathway], 
                      n = 5)
  Down.pathways <- head(Macro2.GSEA[ES < 0][order(pval),][,pathway], 
                        n = 5)
  Macro2.pathways <- c(Up.pathways, 
                       rev(Down.pathways)) 

  # Plot the GSEA.
  print(plotGseaTable(GSEA.list[[i]][Macro2.pathways], 
                     Macro2.FC, 
                     Macro2.GSEA, 
                     gseaParam = 0.5, 
                     pathwayLabelStyle=list(size = 6, 
                                            color = "#2171b5"), 
                     headerLabelStyle = list(size = 8, 
                                             color = "#084594"), 
                     valueStyle = list(size = 10), 
                     axisLabelStyle = list(size = 7)))
}
 
```
        
